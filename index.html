<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Endless Runner</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    #gameOverScreen {
      display: none;
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.8);
      padding: 20px;
      color: white;
      font-family: sans-serif;
      text-align: center;
    }
  </style>
</head>
<body>
<div id="gameOverScreen">
  <h1>Game Over</h1>
  <p id="finalScore"></p>
  <button onclick="restartGame()">Restart</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
<script>
let scene, camera, renderer;
let player;
let obstacles = [];
let moveLeft = false, moveRight = false;
let velocityY = 0, gravity = -0.01, jumpForce = 0.35;
let isGrounded = true;
let isSliding = false, slideTimer = 0, slideDuration = 30;
let score = 0, gameOver = false;
let shieldActive = false;
let finalScore = null, gameOverScreen = null;

init();
animate();

function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Player
  const geometry = new THREE.BoxGeometry(1,1,1);
  const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
  player = new THREE.Mesh(geometry, material);
  player.position.set(0,0.5,5);
  scene.add(player);

  // Ground
  const groundGeo = new THREE.PlaneGeometry(20,200);
  const groundMat = new THREE.MeshBasicMaterial({color:0x444444, side:THREE.DoubleSide});
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = Math.PI/2;
  scene.add(ground);

  camera.position.set(0,5,10);
  camera.lookAt(0,0,0);

  finalScore = document.getElementById("finalScore");
  gameOverScreen = document.getElementById("gameOverScreen");

  // Controls
  window.addEventListener("keydown", keyDown);
  window.addEventListener("keyup", keyUp);
}

function keyDown(e) {
  if (e.key === "ArrowLeft") moveLeft = true;
  if (e.key === "ArrowRight") moveRight = true;
  if (e.code === "Space" && isGrounded && !isSliding) {
    velocityY = jumpForce;
    isGrounded = false;
  }
  if (e.key === "Shift" && isGrounded && !isSliding) {
    isSliding = true;
    slideTimer = slideDuration;
    player.scale.y = 0.5;
    player.position.y = 0.25;
  }
}

function keyUp(e) {
  if (e.key === "ArrowLeft") moveLeft = false;
  if (e.key === "ArrowRight") moveRight = false;
}

function spawnObstacle() {
  const type = Math.floor(Math.random()*3); // 0=normal,1=tall,2=short
  let geo, mat;
  if (type === 0) {
    geo = new THREE.BoxGeometry(1,1,1);
    mat = new THREE.MeshBasicMaterial({color:0xff0000});
  } else if (type === 1) {
    geo = new THREE.BoxGeometry(1,2,1); // tall (must slide)
    mat = new THREE.MeshBasicMaterial({color:0x0000ff});
  } else {
    geo = new THREE.BoxGeometry(1,0.5,1); // short (must jump)
    mat = new THREE.MeshBasicMaterial({color:0xffff00});
  }
  const obs = new THREE.Mesh(geo, mat);
  obs.position.set(Math.floor(Math.random()*3)-1, geo.parameters.height/2, -50);
  obs.userData.type = type;
  scene.add(obs);
  obstacles.push(obs);
}

function animate() {
  if (!gameOver) {
    requestAnimationFrame(animate);
    score++;

    // Move player
    if (moveLeft && player.position.x > -2) player.position.x -= 0.1;
    if (moveRight && player.position.x < 2) player.position.x += 0.1;

    // Jump physics
    velocityY += gravity;
    player.position.y += velocityY;
    if (player.position.y <= (isSliding ? 0.25 : 0.5)) {
      player.position.y = isSliding ? 0.25 : 0.5;
      velocityY = 0;
      isGrounded = true;
    }

    // Slide timer
    if (isSliding) {
      slideTimer--;
      if (slideTimer <= 0) {
        isSliding = false;
        player.scale.y = 1;
        player.position.y = 0.5;
      }
    }

    // Obstacles
    if (Math.random() < 0.02) spawnObstacle();
    obstacles.forEach((obs, i) => {
      obs.position.z += 0.3;
      if (obs.position.z > 10) {
        scene.remove(obs);
        obstacles.splice(i,1);
      }
      // Collision detection
      if (Math.abs(player.position.x - obs.position.x) < 0.9 &&
          Math.abs(player.position.z - obs.position.z) < 0.9) {
        if (obs.userData.type === 0 && player.position.y <= 1.0 && !shieldActive) {
          endGame();
        } else if (obs.userData.type === 1 && !isSliding && !shieldActive) {
          endGame();
        } else if (obs.userData.type === 2 && player.position.y < 1.2 && !shieldActive) {
          endGame();
        }
      }
    });

    renderer.render(scene,camera);
  }
}

function endGame() {
  gameOver = true;
  finalScore.textContent = "Final Score: " + score;
  gameOverScreen.style.display = "block";
}

function restartGame() {
  // Reset
  obstacles.forEach(o=>scene.remove(o));
  obstacles=[];
  score=0; gameOver=false;
  player.position.set(0,0.5,5);
  player.scale.y=1;
  isSliding=false; velocityY=0;
  gameOverScreen.style.display="none";
  animate();
}
</script>
</body>
</html>
